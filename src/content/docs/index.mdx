---
title: "Elevate CSS"
description: Let's Reimagine The Utility First CSS Framework.
template: splash
hero:
  tagline: Elevate Your CSS
  actions:
    - text: Learn More
      link: /guides/2-getting-started/
      icon: right-arrow
    - text: View On Github
      link: https://github.com/DesignInTheBlack/Elevate
      variant: minimal
head:
  - tag: link
    attrs:
      rel: stylesheet
      href: /canvasFix.css 
---

import { Card, CardGrid } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';

<script is:inline>
  document.documentElement.dataset.theme = 'dark'
</script>

## Design, Compiled

Stop translating between design tokens and arbitrary utility classes. Stop memorizing magic numbers. Stop shipping CSS you'll never use.
Elevate compiles utilities directly from your design system. Write `pd:lg` and get exactly the spacing your designer defined. Write `bg:primary` and get exactly the color from your brand palette.
When you write `pd:lg`, Elevate parses your utility string, validates it against your design tokens, and generates the exact CSS rule you need. Nothing exists until you write it. Change your tokens and every compiled utility updates automatically.

<br/>
<br/>

<div id = "starfield">
</div>
<div id="fluid-bg">

  <canvas id="MarqueeCanvas"></canvas>
</div>
<script src="/fluid.js" defer></script>

> "When I am working on a problem, I never think about beauty. But when I have finished, if the solution is not beautiful?"
>
> "... I know it is wrong."
>
> **R. Buckminster Fuller**

<br/>
<br/>
<br/>

<Aside type="caution" title="Please Excuse Our Progress">
In its current iteration (v1.05 - Beta), Elevate CSS is in active development and subject to change. Your feedback is invaluable as this project evolves into a fully realized utility framework.
</Aside>

<br/>





## The Tokens Are The Syntax

No translation layer between your design decisions and your CSS. No memorizing arbitrary class names like `p-4` or `text-lg` that tell you nothing about design intent. Your design language becomes your CSS language, creating a direct pipeline from design system to shipped code.
Change `lg: "2rem"` to `lg: "1.5rem"` in your design tokens and every `pd:lg` across your entire codebase updates instantly. One source of truth. Zero drift. Zero hunting through stylesheets to update spacing values.


<br/>
<br/>
<br/>

```html
/* In your design system */
spacing: { lg: "2rem" }
colors: { primary: "#3b82f6" }

/* In your code */
pd:lg bg:primary

/* Compiles to exactly */
.pd\:lg {
  padding: 2rem;
}
.bg\:primary {
  background-color: #3b82f6;
}
```

<br/>



<br/>


## CSS That Documents Itself

Six months later, when you're debugging a layout issue at 11 PM, which one reads like a sentence describing what you intended? Which one connects to your design system's language?
`pd:lg bg:primary text:inverse flows like natural language` - "padding large, background primary, text inverse." It tells the story of your design decisions using your design system's vocabulary.
`p-4 bg-blue-500 text-white` is a string of arbitrary codes that forces you to decode what p-4 means, remember which 'blue' that `blue-500` represents, and reverse-engineer why those specific values seemed right six months ago.


<br/>
<br/>
<br/>


```html
<div class ="pd:d4:d2 row:x-center:y-center">
    <h1 class ="font:sans:h5 mg-t:d12 /md/ font:h3 /lg/ font:h1">"I Am The Documentation" - Your CSS, Probably.</h1>
</div>
```

<br/>





## Catch Mistakes Before They Catch You

Every utility string gets validated against your actual design tokens during compilation, not when users report broken layouts. Typos become build errors that stop deployment. Off-brand colors become compiler warnings that prevent design system drift. Visual inconsistency becomes structurally impossible because your CSS literally cannot generate values that don't exist in your design system.

<br/>
<br/>
<br/>


```html


‚ùå Invalid Prefixed Value: Unable to determine spacing value "xlarge" 
   in src/components/Button.tsx on line 23

üí° Troubleshooting Tips:
   1. Examine your prefixed value and ensure it matches the expected token type.
   2. If this is a custom modifier, ensure that you are using the correct syntax.

For more information, refer to https://elevate-docs.pages.dev


```

<br/>
<br/>
<br/>
<br/>

<CardGrid stagger>
	<Card title="Generated on Demand" icon="rocket">
		Zero pre-built utilities. CSS gets compiled from your design tokens exactly when you write it.
	</Card>
	<Card title="Build-Time Validation" icon="approve-check-circle">
		Type `pd:xlarge` instead of `pd:xl` and your build fails immediately. Typos become compiler errors.
	</Card>
	<Card title="Semantic Utilities" icon="seti:css">
		`bg:primary` tells you design intent. `bg-blue-500` tells you nothing about why that color was chosen.
	</Card>
	<Card title="Design System Driven" icon="open-book">
		Your tokens define your utilities. Change your design system and every component updates automatically.
	</Card>
</CardGrid>

<br/>

## Responsive Design Made Readable

Your medium breakpoint can be `768px` today and `1024px` tomorrow, and your utilities adapt automatically without touching a single class name. Instead of memorizing that `md:` means `768px` and `lg:` means `1024px`, you work with breakpoints that match your design system's language. When your design team decides tablets should break at `900px` instead, you update one value and every responsive utility adjusts instantly. To top it all off, mobile first breakpoint flags ensure that you always understand what's happening and at what breakpoint.

<br/>
<br/>
<br/>

```html
<div class ="w:c6 /md/ w:c8 /xl/ w:full">
    <h1 class ="text:white:center">I'm Spatially Aware</h1>
</div>
```

<br/>



## States Without The Mess

Contextual styling that groups related properties together instead of scattering them across your class list like `hover:bg-blue-600 hover:text-white hover:scale-105`. No more hunting through dozens of classes to find which hover states belong to which element, or wondering if you forgot to add a focus state that matches your hover state. Everything that changes together stays together, making interactive components predictable and maintainable.

<br/>
<br/>
<br/>

```html
<div class ="pd:d4:d2 row:x-center:y-center">
    <div class ="w:full bg-color:green @hover:[bg-color:red_font:semibold_text:white]"><p>What Happens On Hover, Again?</p></div>
</div>
```

<br/>



## The End of C(SS)haos

Write `bg:primary` and get exactly the color your designer specified in your brand guidelines, not some approximation you remembered. Change that color definition once in your design tokens and watch every component, every page, every instance update automatically. No more drift between what designers specify and what ships. No more guesswork about which blue is the "right" blue. No more broken designs because someone used `bg-blue-400` instead of `bg-blue-500`.


<br/>
<br/>


## Join The Community

Let's Build Something Great Together!

import { Icon } from '@astrojs/starlight/components';

<div style="display: flex; align-items: center; gap: 0.5rem;">
  <Icon name="discord" />
  <a href="https://discord.gg/T3X2vBYA" style="text-decoration: none;">Join The Discord</a>
</div>
<div style="display: flex; align-items: center; gap: 0.5rem;">
  <Icon name="github" />
  <a href="https://github.com/DesignInTheBlack/Elevate" style="text-decoration: none;">Explore The Repository</a>
</div>